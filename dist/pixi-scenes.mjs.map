{
  "version": 3,
  "sources": ["../src/pixi-scenes.mjs"],
  "sourcesContent": ["import {\n  Container,\n  Ticker,\n} from \"https://cdn.jsdelivr.net/npm/pixi.js/dist/pixi.mjs\";\n\n/**\n * An abstract scene to be extended. This is intended to be\n * only type of direct children of the Application, and these\n * are managed by {@link SceneManager}.\n * @abstract\n */\nexport class Scene extends Container {\n  /**\n   * A reference to the scene manager.\n   * This can only be accessed within and after {@link Scene#init}\n   */\n  manager = null;\n  /**\n   * This is basically just a constructor that is called directly after\n   * the scene is registered. The purpose of this is \n   * so that {@link Scene#manager} would be valid when the scene is being\n   * initialized in case you need access to, for example, \n   * {@link SceneManager#screen}.\n   */\n  init() {}\n  /**\n   * Called when the scene becomes active, and returns an iterator for animation.\n   * The generator is advanced every frame until it returns, so\n   * you can animate the enter animation for as long as you need to.\n   * The delta is also passed into the generator every tick, which you can access with\n   * the {@linkcode https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next#sending_values_to_the_generator|yield}\n   * keyword \u2014 check out the examples.\n   * This will play after the previous scene's {@link SceneManager#end}\n   * and before this scene's {@link SceneManager#tick}.\n   * @param {number} delta -\n   *   see {@linkcode https://pixijs.download/release/docs/ticker.Ticker.html#deltaTime|Ticker.deltaTime}\n   * @param {*} [message=null] - This contains anything that the previous scene wanted to send\n   * @returns {Generator<undefined, undefined, number>}\n   */\n  *start(delta, message) {}\n  /**\n   * This gets called every time {@link https://pixijs.download/release/docs/ticker.Ticker.html|Pixi's Ticker}\n   * gets ticked. This runs after the generator from {@link Scene#init} terminates.\n   * @param {number} delta - \n   *   see {@linkcode https://pixijs.download/release/docs/ticker.Ticker.html#deltaTime|Ticker.deltaTime}\n   */\n  tick(delta) {}\n  /**\n   * Similar to {@link SceneManager#start}, but this will be called when this scene will be ending.\n   * The generator is advanced every frame until it returns, so\n   * you can animate the exit animation for as long as you need to.\n   * This will play before the next scene's {@link SceneManager#start}.\n   * Delta is passed into the generator, which can be accessed with \n   * {@linkcode https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next#sending_values_to_the_generator|yield}.\n   * @param {number} delta - \n   *   see {@linkcode https://pixijs.download/release/docs/ticker.Ticker.html#deltaTime|Ticker.deltaTime}\n   * @returns {Generator<undefined, undefined, number>}\n   */\n  *end(delta) {}\n}\n\n/** \n A scene manager that can hold scenes.\n */\nexport class SceneManager {\n  /**\n   The scene being displayed currently.\n   @type {Scene}\n   */\n  currentScene = null;\n  _endAnimIter = null;\n  _queuedScene = null;\n  _queuedSceneMessage = null;\n  _startAnimIter = null;\n  _scenes = new Map();\n  /**\n   * The ticker that this manager uses.\n   * @type {PIXI.Ticker}\n   */\n  ticker = Ticker.shared;\n  /**\n   * A reference to the Application of the manager\n   * @type {PIXI.Application}\n   */\n  app;\n  /**\n   * A reference to the screen of the app.\n   * This is implemented because getting the app's \n   * width and height is a common action.\n   * @type {PIXI.Screen}\n   */\n  screen;\n  /**\n   * Creates a new SceneManager over an application.\n   * @param {PIXI.Application} application\n   */\n  constructor(application) {\n    this.app = application;\n    this.screen = application.screen;\n    this.ticker.add(\n      function ({ deltaTime }) {\n        if (this._endAnimIter) {\n          if (this._endAnimIter.next(deltaTime).done) {\n            this._endAnimIter = null;\n            this.app.stage.removeChild(this.currentScene);\n            this.currentScene = this._queuedScene;\n            this.app.stage.addChild(this._queuedScene);\n            this._startAnimIter = this.currentScene.start(\n              deltaTime,\n              this._queuedSceneMessage\n            );\n            this._queuedScene = this._queuedSceneMessage = null;\n          }\n        }\n        if (this._startAnimIter) {\n          if (this._startAnimIter.next(deltaTime).done) {\n            this._startAnimIter = null;\n          }\n        }\n        if (this.currentScene) {\n          this.currentScene.tick(deltaTime);\n        }\n      }.bind(this)\n    );\n  }\n  /**\n   * Registers a scene with a specified sceneName, and calls the scene's {@link Scene#init} function\n   * @type {string} sceneName\n   * @type {Scene} scene\n   */\n  register(sceneName, scene) {\n    scene.manager = this;\n    this._scenes.set(sceneName, scene);\n    scene.init();\n  }\n  /**\n   * Changes the scene and optionally sends a message to the new scene\n   * @type {string?} sceneName - scene must be registered first. If null, there will be no scene displayed.\n   * @type {*} message - optional message sent to the next scene's {@link SceneManager#start}\n   */\n  changeSceneTo(sceneName = null, message = null) {\n    if (this.currentScene) {\n      this._endAnimIter = this.currentScene.end();\n\n      this._queuedSceneMessage = message;\n      if (sceneName !== null) {\n        const queuedScene = this._scenes.get(sceneName);\n        if (!queuedScene) {\n          throw new Error(`Scene ${sceneName} not found.`);\n        }\n        this._queuedScene = queuedScene;\n      }\n    } else {\n      if (sceneName !== null) {\n        const currentScene = this._scenes.get(sceneName);\n        if (!currentScene) {\n          throw new Error(`Scene ${sceneName} not found.`);\n        }\n        this.currentScene = currentScene;\n        this.app.stage.addChild(currentScene);\n      }\n    }\n  }\n}\n"],
  "mappings": "oKAAA,OACE,aAAAA,EACA,UAAAC,MACK,qDAQA,IAAMC,EAAN,cAAoBC,CAAU,CAA9B,kCAKLC,EAAA,eAAU,MAQV,MAAO,CAAC,CAeR,CAAC,MAAMC,EAAOC,EAAS,CAAC,CAOxB,KAAKD,EAAO,CAAC,CAYb,CAAC,IAAIA,EAAO,CAAC,CACf,EAKaE,EAAN,KAAmB,CAgCxB,YAAYC,EAAa,CA3BzBJ,EAAA,oBAAe,MACfA,EAAA,oBAAe,MACfA,EAAA,oBAAe,MACfA,EAAA,2BAAsB,MACtBA,EAAA,sBAAiB,MACjBA,EAAA,eAAU,IAAI,KAKdA,EAAA,cAASK,EAAO,QAKhBL,EAAA,YAOAA,EAAA,eAME,KAAK,IAAMI,EACX,KAAK,OAASA,EAAY,OAC1B,KAAK,OAAO,IACV,SAAU,CAAE,UAAAE,CAAU,EAAG,CACnB,KAAK,cACH,KAAK,aAAa,KAAKA,CAAS,EAAE,OACpC,KAAK,aAAe,KACpB,KAAK,IAAI,MAAM,YAAY,KAAK,YAAY,EAC5C,KAAK,aAAe,KAAK,aACzB,KAAK,IAAI,MAAM,SAAS,KAAK,YAAY,EACzC,KAAK,eAAiB,KAAK,aAAa,MACtCA,EACA,KAAK,mBACP,EACA,KAAK,aAAe,KAAK,oBAAsB,MAG/C,KAAK,gBACH,KAAK,eAAe,KAAKA,CAAS,EAAE,OACtC,KAAK,eAAiB,MAGtB,KAAK,cACP,KAAK,aAAa,KAAKA,CAAS,CAEpC,EAAE,KAAK,IAAI,CACb,CACF,CAMA,SAASC,EAAWC,EAAO,CACzBA,EAAM,QAAU,KAChB,KAAK,QAAQ,IAAID,EAAWC,CAAK,EACjCA,EAAM,KAAK,CACb,CAMA,cAAcD,EAAY,KAAML,EAAU,KAAM,CAC9C,GAAI,KAAK,cAIP,GAHA,KAAK,aAAe,KAAK,aAAa,IAAI,EAE1C,KAAK,oBAAsBA,EACvBK,IAAc,KAAM,CACtB,IAAME,EAAc,KAAK,QAAQ,IAAIF,CAAS,EAC9C,GAAI,CAACE,EACH,MAAM,IAAI,MAAM,SAASF,CAAS,aAAa,EAEjD,KAAK,aAAeE,CACtB,UAEIF,IAAc,KAAM,CACtB,IAAMG,EAAe,KAAK,QAAQ,IAAIH,CAAS,EAC/C,GAAI,CAACG,EACH,MAAM,IAAI,MAAM,SAASH,CAAS,aAAa,EAEjD,KAAK,aAAeG,EACpB,KAAK,IAAI,MAAM,SAASA,CAAY,CACtC,CAEJ,CACF",
  "names": ["Container", "Ticker", "Scene", "Container", "__publicField", "delta", "message", "SceneManager", "application", "Ticker", "deltaTime", "sceneName", "scene", "queuedScene", "currentScene"]
}
